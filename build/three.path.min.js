// github.com/shawn0326/three.path
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t.THREE||{},t.THREE)}(this,(function(t,e){"use strict";class s{constructor(){this.pos=new e.Vector3,this.dir=new e.Vector3,this.right=new e.Vector3,this.up=new e.Vector3,this.dist=0,this.widthScale=1,this.sharp=!1}lerpPathPoints(t,e,s){this.pos.lerpVectors(t.pos,e.pos,s),this.dir.lerpVectors(t.dir,e.dir,s),this.up.lerpVectors(t.up,e.up,s),this.right.lerpVectors(t.right,e.right,s),this.dist=(e.dist-t.dist)*s+t.dist,this.widthScale=(e.widthScale-t.widthScale)*s+t.widthScale}copy(t){this.pos.copy(t.pos),this.dir.copy(t.dir),this.up.copy(t.up),this.right.copy(t.right),this.dist=t.dist,this.widthScale=t.widthScale}}const i=new e.Vector3,r=new e.Vector3,a=new e.Vector3,n=new e.Matrix4,o=new e.QuadraticBezierCurve3;class u extends e.BufferGeometry{constructor(t=3e3,e=!1){super(),isNaN(t)?this._initByData(t.pathPointList,t.options,t.usage,e):this._initByMaxVertex(t,e)}_initByMaxVertex(t,s){this.setAttribute("position",new e.BufferAttribute(new Float32Array(3*t),3).setUsage(e.DynamicDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(3*t),3).setUsage(e.DynamicDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(2*t),2).setUsage(e.DynamicDrawUsage)),s&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(2*t),2).setUsage(e.DynamicDrawUsage)),this.drawRange.start=0,this.drawRange.count=0,this.setIndex(t>65536?new e.Uint32BufferAttribute(3*t,1):new e.Uint16BufferAttribute(3*t,1))}_initByData(t,s={},i,r){const a=h(t,s,r);a&&0!==a.count?(this.setAttribute("position",new e.BufferAttribute(new Float32Array(a.position),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(a.normal),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(a.uv),2).setUsage(i||e.StaticDrawUsage)),r&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(a.uv2),2).setUsage(i||e.StaticDrawUsage)),this.setIndex(a.position.length/3>65536?new e.Uint32BufferAttribute(a.indices,1):new e.Uint16BufferAttribute(a.indices,1))):this._initByMaxVertex(2,r)}update(t,e={}){const s=!!this.getAttribute("uv2"),i=h(t,e,s);i?(this._updateAttributes(i.position,i.normal,i.uv,s?i.uv2:null,i.indices),this.drawRange.count=i.count):this.drawRange.count=0}_resizeAttribute(t,s){let i=this.getAttribute(t);for(;i.array.length<s;){const s=i.array.length,r=new e.BufferAttribute(new Float32Array(2*s),i.itemSize,i.normalized);r.name=i.name,r.usage=i.usage,this.setAttribute(t,r),i=r}}_resizeIndex(t){let s=this.getIndex();for(;s.array.length<t;){const t=s.array.length,i=new e.BufferAttribute(2*t>65535?new Uint32Array(2*t):new Uint16Array(2*t),1);i.name=s.name,i.usage=s.usage,this.setIndex(i),s=i}}_updateAttributes(t,e,s,i,r){this._resizeAttribute("position",t.length);const a=this.getAttribute("position");a.array.set(t,0),a.addUpdateRange?(a.clearUpdateRanges(),a.addUpdateRange(0,t.length)):a.updateRange.count=t.length,a.needsUpdate=!0,this._resizeAttribute("normal",e.length);const n=this.getAttribute("normal");n.array.set(e,0),n.addUpdateRange?(n.clearUpdateRanges(),n.addUpdateRange(0,e.length)):n.updateRange.count=e.length,n.needsUpdate=!0,this._resizeAttribute("uv",s.length);const o=this.getAttribute("uv");if(o.array.set(s,0),o.addUpdateRange?(o.clearUpdateRanges(),o.addUpdateRange(0,s.length)):o.updateRange.count=s.length,o.needsUpdate=!0,i){this._resizeAttribute("uv2",i.length);const t=this.getAttribute("uv2");t.array.set(i,0),t.addUpdateRange?(t.clearUpdateRanges(),t.addUpdateRange(0,i.length)):t.updateRange.count=i.length,t.needsUpdate=!0}this._resizeIndex(r.length);const u=this.getIndex();u.set(r,0),u.addUpdateRange?(u.clearUpdateRanges(),u.addUpdateRange(0,r.length)):u.updateRange.count=r.length,u.needsUpdate=!0}}function h(t,i,r=!1){const a=i.width||.1,n=void 0!==i.progress?i.progress:1,o=void 0===i.arrow||i.arrow,u=void 0!==i.side?i.side:"both",h=a/2,c="both"!==u?a/2:a,d=t.distance(),l=n*d;if(0==d)return null;const p=h/c,g=h/d;let y=0;const f=[],w=[],b=[],A=[],m=[];let x=0;const z=new e.Vector3,U=new e.Vector3,V=new e.Vector3,v=new e.Vector3,B=new e.Vector3,S=new e.Vector3;function _(t){const e=0===f.length,s=t.sharp&&!e,i=t.dist/c,a=t.dist/d,n=t.dir,o=t.up,l=t.right;if("left"!==u?z.copy(l).multiplyScalar(h*t.widthScale):z.set(0,0,0),"right"!==u?U.copy(l).multiplyScalar(-h*t.widthScale):U.set(0,0,0),z.add(t.pos),U.add(t.pos),s){V.fromArray(f,f.length-6).sub(U),v.fromArray(f,f.length-3).sub(z);const t=V.length()-v.length();let e,s;t>0?(e=V,s=U):(e=v,s=z),B.copy(e).setLength(Math.abs(t)).add(s);const u=S.copy(s).sub(B).normalize().dot(n)*S.copy(s).sub(B).length()*2;S.copy(n).setLength(u).add(B),t>0?(f.push(B.x,B.y,B.z,z.x,z.y,z.z,U.x,U.y,U.z,z.x,z.y,z.z,S.x,S.y,S.z,z.x,z.y,z.z),x+=6,m.push(x-6,x-8,x-7,x-6,x-7,x-5,x-4,x-6,x-5,x-2,x-4,x-1),y+=12):(f.push(U.x,U.y,U.z,B.x,B.y,B.z,U.x,U.y,U.z,z.x,z.y,z.z,U.x,U.y,U.z,S.x,S.y,S.z),x+=6,m.push(x-6,x-8,x-7,x-6,x-7,x-5,x-6,x-5,x-3,x-2,x-3,x-1),y+=12),w.push(o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z),b.push(i-p,0,i-p,1,i,0,i,1,i+p,0,i+p,1),r&&A.push(a-g,0,a-g,1,a,0,a,1,a+g,0,a+g,1)}else f.push(U.x,U.y,U.z,z.x,z.y,z.z),w.push(o.x,o.y,o.z,o.x,o.y,o.z),b.push(i,0,i,1),r&&A.push(a,0,a,1),x+=2,e||(m.push(x-2,x-4,x-3,x-2,x-3,x-1),y+=6)}const R=new e.Vector3;let M;if(l>0)for(let e=0;e<t.count;e++){const i=t.array[e];if(i.dist>l){const r=t.array[e-1];M=new s;const a=(l-r.dist)/(i.dist-r.dist);M.lerpPathPoints(r,i,a),_(M);break}_(i)}else M=t.array[0];return o&&(M=M||t.array[t.count-1],function(t){const e=t.dir,s=t.up,i=t.right,n=t.dist/c,o=t.dist/d;"left"!==u?z.copy(i).multiplyScalar(2*h):z.set(0,0,0),"right"!==u?U.copy(i).multiplyScalar(2*-h):U.set(0,0,0),R.copy(e).setLength(3*h),z.add(t.pos),U.add(t.pos),R.add(t.pos),f.push(U.x,U.y,U.z,z.x,z.y,z.z,R.x,R.y,R.z),w.push(s.x,s.y,s.z,s.x,s.y,s.z,s.x,s.y,s.z),b.push(n,"both"!==u?"right"!==u?-2:0:-.5,n,"both"!==u?"left"!==u?2:0:1.5,n+1.5,"both"!==u?0:.5),r&&A.push(o,"both"!==u?"right"!==u?-2:0:-.5,o,"both"!==u?"left"!==u?2:0:1.5,o+1.5*a/d,"both"!==u?0:.5),x+=3,m.push(x-1,x-3,x-2),y+=3}(M)),{position:f,normal:w,uv:b,uv2:A,indices:m,count:y}}function c(t,i,r=!1){const a=i.radius||.1,n=void 0!==i.progress?i.progress:1,o=Math.max(2,i.radialSegments||8),u=i.startRad||0,h=2*a*Math.PI,c=t.distance(),d=n*c;if(0==d)return null;let l=0;const p=[],g=[],y=[],f=[],w=[];let b=0;const A=new e.Vector3;function m(t,e,s){const i=0===p.length,a=t.dist/h,n=t.dist/c;for(let i=0;i<=s;i++){let o=i;o==s&&(o=0),A.copy(t.up).applyAxisAngle(t.dir,u+2*Math.PI*o/s).normalize(),p.push(t.pos.x+A.x*e*t.widthScale,t.pos.y+A.y*e*t.widthScale,t.pos.z+A.z*e*t.widthScale),g.push(A.x,A.y,A.z),y.push(a,i/s),r&&f.push(n,i/s),b++}if(!i){const t=b-2*(s+1),e=b-(s+1);for(let i=0;i<s;i++)w.push(e+i,t+i,t+i+1,e+i,t+i+1,e+i+1),l+=6}}if(d>0)for(let e=0;e<t.count;e++){const i=t.array[e];if(i.dist>d){const r=t.array[e-1],n=new s,u=(d-r.dist)/(i.dist-r.dist);n.lerpPathPoints(r,i,u),m(n,a,o);break}m(i,a,o)}return{position:p,normal:g,uv:y,uv2:f,indices:w,count:l}}t.PathGeometry=u,t.PathPointList=class{constructor(){this.array=[],this.count=0}set(t,s=.1,i=10,r=null,a=!1){if((t=t.slice(0)).length<2)return console.warn("PathPointList: points length less than 2."),void(this.count=0);a&&!t[0].equals(t[t.length-1])&&t.push((new e.Vector3).copy(t[0]));for(let e=0,n=t.length;e<n;e++)if(0===e)this._start(t[e],t[e+1],r);else if(e===n-1)if(a){this._corner(t[e],t[1],s,i,r);const a=this.array[0].dist;this.array[0].copy(this.array[this.count-1]),this.array[0].dist=a}else this._end(t[e]);else this._corner(t[e],t[e+1],s,i,r)}distance(){return this.count>0?this.array[this.count-1].dist:0}_getByIndex(t){return this.array[t]||(this.array[t]=new s),this.array[t]}_start(t,e,s){this.count=0;const i=this._getByIndex(this.count);if(i.pos.copy(t),i.dir.subVectors(e,t),s)i.up.copy(s);else{let t=Number.MAX_VALUE;const e=Math.abs(i.dir.x),s=Math.abs(i.dir.y),r=Math.abs(i.dir.z);e<t&&(t=e,i.up.set(1,0,0)),s<t&&(t=s,i.up.set(0,1,0)),r<t&&i.up.set(0,0,1)}i.right.crossVectors(i.dir,i.up).normalize(),i.up.crossVectors(i.right,i.dir).normalize(),i.dist=0,i.widthScale=1,i.sharp=!1,i.dir.normalize(),this.count++}_end(t){const e=this.array[this.count-1],s=this._getByIndex(this.count);s.pos.copy(t),s.dir.subVectors(t,e.pos);const r=s.dir.length();s.dir.normalize(),s.up.copy(e.up);const a=i.crossVectors(e.dir,s.dir);if(a.length()>Number.EPSILON){a.normalize();const t=Math.acos(Math.min(Math.max(e.dir.dot(s.dir),-1),1));s.up.applyMatrix4(n.makeRotationAxis(a,t))}s.right.crossVectors(s.dir,s.up).normalize(),s.dist=e.dist+r,s.widthScale=1,s.sharp=!1,this.count++}_corner(t,e,s,a,n){if(s>0&&a>0){const u=function(t,e,s,a,n,o){const u=i.subVectors(e,t),h=r.subVectors(s,e),c=u.length(),d=h.length();u.normalize(),h.normalize();const l=Math.min(.999999*(n?c/2:c),a);o.v0.copy(e).sub(u.multiplyScalar(l)),o.v1.copy(e);const p=Math.min(d/2*.999999,a);return o.v2.copy(e).add(h.multiplyScalar(p)),o}(this.array[this.count-1].pos,t,e,s,this.count-1==0,o),h=u.getPoints(a);for(let t=0;t<a;t++)this._sharpCorner(h[t],h[t+1],n,0===t?1:0);h[a].equals(e)||this._sharpCorner(h[a],e,n,2)}else this._sharpCorner(t,e,n,0,!0)}_sharpCorner(t,e,s,o=0,u=!1){const h=this.array[this.count-1],c=this._getByIndex(this.count),d=i.subVectors(t,h.pos),l=r.subVectors(e,t),p=d.length();if(d.normalize(),l.normalize(),c.pos.copy(t),1===o?c.dir.copy(d):2===o?c.dir.copy(l):(c.dir.addVectors(d,l),c.dir.normalize()),s)1===c.dir.dot(s)?c.right.crossVectors(l,s).normalize():c.right.crossVectors(c.dir,s).normalize(),c.up.crossVectors(c.right,c.dir).normalize();else{c.up.copy(h.up);const t=a.crossVectors(h.dir,c.dir);if(t.length()>Number.EPSILON){t.normalize();const e=Math.acos(Math.min(Math.max(h.dir.dot(c.dir),-1),1));c.up.applyMatrix4(n.makeRotationAxis(t,e))}c.right.crossVectors(c.dir,c.up).normalize()}c.dist=h.dist+p;const g=d.dot(l);c.widthScale=Math.min(1/Math.sqrt((1+g)/2),1.415)||1,c.sharp=Math.abs(g-1)>.05&&u,this.count++}},t.PathTubeGeometry=class extends u{constructor(t=1e3,e=!1){super(t,e)}_initByData(t,s={},i,r){const a=c(t,s,r);a&&0!==a.count?(this.setAttribute("position",new e.BufferAttribute(new Float32Array(a.position),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(a.normal),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(a.uv),2).setUsage(i||e.StaticDrawUsage)),r&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(a.uv2),2).setUsage(i||e.StaticDrawUsage)),this.setIndex(a.position.length/3>65536?new e.Uint32BufferAttribute(a.indices,1):new e.Uint16BufferAttribute(a.indices,1))):this._initByMaxVertex(2,r)}update(t,e={}){const s=!!this.getAttribute("uv2"),i=c(t,e,s);i?(this._updateAttributes(i.position,i.normal,i.uv,s?i.uv2:null,i.indices),this.drawRange.count=i.count):this.drawRange.count=0}}}));
