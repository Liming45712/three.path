// github.com/shawn0326/three.path
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t.THREE||{})}(this,(function(t){"use strict";class e{constructor(){this.pos=new THREE.Vector3,this.dir=new THREE.Vector3,this.right=new THREE.Vector3,this.up=new THREE.Vector3,this.dist=0,this.widthScale=1,this.sharp=!1}lerpPathPoints(t,e,s){this.pos.lerpVectors(t.pos,e.pos,s),this.dir.lerpVectors(t.dir,e.dir,s),this.up.lerpVectors(t.up,e.up,s),this.right.lerpVectors(t.right,e.right,s),this.dist=(e.dist-t.dist)*s+t.dist,this.widthScale=(e.widthScale-t.widthScale)*s+t.widthScale}copy(t){this.pos.copy(t.pos),this.dir.copy(t.dir),this.up.copy(t.up),this.right.copy(t.right),this.dist=t.dist,this.widthScale=t.widthScale}}const s=new THREE.Vector3,i=new THREE.Vector3,r=new THREE.Vector3,n=new THREE.Matrix4,o=new THREE.QuadraticBezierCurve3;class a extends THREE.BufferGeometry{constructor(t=3e3,e=!1){super(),isNaN(t)?this._initByData(t.pathPointList,t.options,t.usage,e):this._initByMaxVertex(t,e)}_initByMaxVertex(t,e){this.setAttribute("position",new THREE.BufferAttribute(new Float32Array(3*t),3).setUsage(THREE.DynamicDrawUsage)),this.setAttribute("normal",new THREE.BufferAttribute(new Float32Array(3*t),3).setUsage(THREE.DynamicDrawUsage)),this.setAttribute("uv",new THREE.BufferAttribute(new Float32Array(2*t),2).setUsage(THREE.DynamicDrawUsage)),e&&this.setAttribute("uv2",new THREE.BufferAttribute(new Float32Array(2*t),2).setUsage(THREE.DynamicDrawUsage)),this.drawRange.start=0,this.drawRange.count=0,this.setIndex(t>65536?new THREE.Uint32BufferAttribute(3*t,1):new THREE.Uint16BufferAttribute(3*t,1))}_initByData(t,e={},s,i){const r=u(t,e,i);r&&0!==r.count?(this.setAttribute("position",new THREE.BufferAttribute(new Float32Array(r.position),3).setUsage(s||THREE.StaticDrawUsage)),this.setAttribute("normal",new THREE.BufferAttribute(new Float32Array(r.normal),3).setUsage(s||THREE.StaticDrawUsage)),this.setAttribute("uv",new THREE.BufferAttribute(new Float32Array(r.uv),2).setUsage(s||THREE.StaticDrawUsage)),i&&this.setAttribute("uv2",new THREE.BufferAttribute(new Float32Array(r.uv2),2).setUsage(s||THREE.StaticDrawUsage)),this.setIndex(r.position.length/3>65536?new THREE.Uint32BufferAttribute(r.indices,1):new THREE.Uint16BufferAttribute(r.indices,1))):this._initByMaxVertex(2,i)}update(t,e={}){const s=!!this.getAttribute("uv2"),i=u(t,e,s);i?(this._updateAttributes(i.position,i.normal,i.uv,s?i.uv2:null,i.indices),this.drawRange.count=i.count):this.drawRange.count=0}_resizeAttribute(t,e){let s=this.getAttribute(t);for(;s.array.length<e;){const e=s.array.length,i=new THREE.BufferAttribute(new Float32Array(2*e),s.itemSize,s.normalized);i.name=s.name,i.usage=s.usage,this.setAttribute(t,i),s=i}}_resizeIndex(t){let e=this.getIndex();for(;e.array.length<t;){const t=e.array.length,s=new THREE.BufferAttribute(2*t>65535?new Uint32Array(2*t):new Uint16Array(2*t),1);s.name=e.name,s.usage=e.usage,this.setIndex(s),e=s}}_updateAttributes(t,e,s,i,r){this._resizeAttribute("position",t.length);const n=this.getAttribute("position");n.array.set(t,0),n.updateRange.count=t.length,n.needsUpdate=!0,this._resizeAttribute("normal",e.length);const o=this.getAttribute("normal");o.array.set(e,0),o.updateRange.count=e.length,o.needsUpdate=!0,this._resizeAttribute("uv",s.length);const a=this.getAttribute("uv");if(a.array.set(s,0),a.updateRange.count=s.length,a.needsUpdate=!0,i){this._resizeAttribute("uv2",i.length);const t=this.getAttribute("uv2");t.array.set(i,0),t.updateRange.count=i.length,t.needsUpdate=!0}this._resizeIndex(r.length);const u=this.getIndex();u.set(r,0),u.updateRange.count=r.length,u.needsUpdate=!0}}function u(t,s,i=!1){const r=s.width||.1,n=void 0!==s.progress?s.progress:1,o=void 0===s.arrow||s.arrow,a=void 0!==s.side?s.side:"both",u=r/2,h="both"!==a?r/2:r,c=t.distance(),d=n*c;if(0==c)return null;const l=u/h,p=u/c;let y=0;const g=[],E=[],f=[],w=[],b=[];let A=0;const R=new THREE.Vector3,m=new THREE.Vector3,x=new THREE.Vector3,z=new THREE.Vector3,T=new THREE.Vector3,H=new THREE.Vector3;function V(t){const e=0===g.length,s=t.sharp&&!e,r=t.dist/h,n=t.dist/c,o=t.dir,d=t.up,V=t.right;if("left"!==a?R.copy(V).multiplyScalar(u*t.widthScale):R.set(0,0,0),"right"!==a?m.copy(V).multiplyScalar(-u*t.widthScale):m.set(0,0,0),R.add(t.pos),m.add(t.pos),s){x.fromArray(g,g.length-6).sub(m),z.fromArray(g,g.length-3).sub(R);const t=x.length()-z.length();let e,s;t>0?(e=x,s=m):(e=z,s=R),T.copy(e).setLength(Math.abs(t)).add(s);let a=H.copy(s).sub(T).normalize().dot(o)*H.copy(s).sub(T).length()*2;H.copy(o).setLength(a).add(T),t>0?(g.push(T.x,T.y,T.z,R.x,R.y,R.z,m.x,m.y,m.z,R.x,R.y,R.z,H.x,H.y,H.z,R.x,R.y,R.z),A+=6,b.push(A-6,A-8,A-7,A-6,A-7,A-5,A-4,A-6,A-5,A-2,A-4,A-1),y+=12):(g.push(m.x,m.y,m.z,T.x,T.y,T.z,m.x,m.y,m.z,R.x,R.y,R.z,m.x,m.y,m.z,H.x,H.y,H.z),A+=6,b.push(A-6,A-8,A-7,A-6,A-7,A-5,A-6,A-5,A-3,A-2,A-3,A-1),y+=12),E.push(d.x,d.y,d.z,d.x,d.y,d.z,d.x,d.y,d.z,d.x,d.y,d.z,d.x,d.y,d.z,d.x,d.y,d.z),f.push(r-l,0,r-l,1,r,0,r,1,r+l,0,r+l,1),i&&w.push(n-p,0,n-p,1,n,0,n,1,n+p,0,n+p,1)}else g.push(m.x,m.y,m.z,R.x,R.y,R.z),E.push(d.x,d.y,d.z,d.x,d.y,d.z),f.push(r,0,r,1),i&&w.push(n,0,n,1),A+=2,e||(b.push(A-2,A-4,A-3,A-2,A-3,A-1),y+=6)}const U=new THREE.Vector3;let v;if(d>0)for(let s=0;s<t.count;s++){const i=t.array[s];if(i.dist>d){const r=t.array[s-1];v=new e;const n=(d-r.dist)/(i.dist-r.dist);v.lerpPathPoints(r,i,n),V(v);break}V(i)}else v=t.array[0];return o&&(v=v||t.array[t.count-1],function(t){const e=t.dir,s=t.up,n=t.right,o=t.dist/h,d=t.dist/c;"left"!==a?R.copy(n).multiplyScalar(2*u):R.set(0,0,0),"right"!==a?m.copy(n).multiplyScalar(2*-u):m.set(0,0,0),U.copy(e).setLength(3*u),R.add(t.pos),m.add(t.pos),U.add(t.pos),g.push(m.x,m.y,m.z,R.x,R.y,R.z,U.x,U.y,U.z),E.push(s.x,s.y,s.z,s.x,s.y,s.z,s.x,s.y,s.z),f.push(o,"both"!==a?"right"!==a?-2:0:-.5,o,"both"!==a?"left"!==a?2:0:1.5,o+1.5,"both"!==a?0:.5),i&&w.push(d,"both"!==a?"right"!==a?-2:0:-.5,d,"both"!==a?"left"!==a?2:0:1.5,d+1.5*r/c,"both"!==a?0:.5),A+=3,b.push(A-1,A-3,A-2),y+=3}(v)),{position:g,normal:E,uv:f,uv2:w,indices:b,count:y}}function h(t,s,i=!1){const r=s.radius||.1,n=void 0!==s.progress?s.progress:1,o=Math.max(2,s.radialSegments||8),a=s.startRad||0,u=2*r*Math.PI,h=t.distance(),c=n*h;if(0==c)return null;let d=0;const l=[],p=[],y=[],g=[],E=[];let f=0;const w=new THREE.Vector3;function b(t,e,s){const r=0===l.length,n=t.dist/u,o=t.dist/h;for(let r=0;r<=s;r++){let u=r;u==s&&(u=0),w.copy(t.up).applyAxisAngle(t.dir,a+2*Math.PI*u/s).normalize(),l.push(t.pos.x+w.x*e*t.widthScale,t.pos.y+w.y*e*t.widthScale,t.pos.z+w.z*e*t.widthScale),p.push(w.x,w.y,w.z),y.push(n,r/s),i&&g.push(o,r/s),f++}if(!r){const t=f-2*(s+1),e=f-(s+1);for(let i=0;i<s;i++)E.push(e+i,t+i,t+i+1,e+i,t+i+1,e+i+1),d+=6}}if(c>0)for(let s=0;s<t.count;s++){const i=t.array[s];if(i.dist>c){const n=t.array[s-1],a=new e,u=(c-n.dist)/(i.dist-n.dist);a.lerpPathPoints(n,i,u),b(a,r,o);break}b(i,r,o)}return{position:l,normal:p,uv:y,uv2:g,indices:E,count:d}}t.PathGeometry=a,t.PathPointList=class{constructor(){this.array=[],this.count=0}set(t,e=.1,s=10,i=null,r=!1){if((t=t.slice(0)).length<2)return console.warn("PathPointList: points length less than 2."),void(this.count=0);r&&!t[0].equals(t[t.length-1])&&t.push((new THREE.Vector3).copy(t[0]));for(let n=0,o=t.length;n<o;n++)if(0===n)this._start(t[n],t[n+1],i);else if(n===o-1)if(r){this._corner(t[n],t[1],e,s,i);const r=this.array[0].dist;this.array[0].copy(this.array[this.count-1]),this.array[0].dist=r}else this._end(t[n]);else this._corner(t[n],t[n+1],e,s,i)}distance(){return this.count>0?this.array[this.count-1].dist:0}_getByIndex(t){return this.array[t]||(this.array[t]=new e),this.array[t]}_start(t,e,s){this.count=0;const i=this._getByIndex(this.count);if(i.pos.copy(t),i.dir.subVectors(e,t),s)i.up.copy(s);else{let t=Number.MAX_VALUE;const e=Math.abs(i.dir.x),s=Math.abs(i.dir.y),r=Math.abs(i.dir.z);e<t&&(t=e,i.up.set(1,0,0)),s<t&&(t=s,i.up.set(0,1,0)),r<t&&i.up.set(0,0,1)}i.right.crossVectors(i.dir,i.up).normalize(),i.up.crossVectors(i.right,i.dir).normalize(),i.dist=0,i.widthScale=1,i.sharp=!1,i.dir.normalize(),this.count++}_end(t){const e=this.array[this.count-1],i=this._getByIndex(this.count);i.pos.copy(t),i.dir.subVectors(t,e.pos);const r=i.dir.length();i.dir.normalize(),i.up.copy(e.up);const o=s.crossVectors(e.dir,i.dir);if(o.length()>Number.EPSILON){o.normalize();const t=Math.acos(Math.min(Math.max(e.dir.dot(i.dir),-1),1));i.up.applyMatrix4(n.makeRotationAxis(o,t))}i.right.crossVectors(i.dir,i.up).normalize(),i.dist=e.dist+r,i.widthScale=1,i.sharp=!1,this.count++}_corner(t,e,r,n,a){if(r>0&&n>0){const u=function(t,e,r,n,o,a){const u=s.subVectors(e,t),h=i.subVectors(r,e),c=u.length(),d=h.length();u.normalize(),h.normalize();const l=Math.min(.999999*(o?c/2:c),n);a.v0.copy(e).sub(u.multiplyScalar(l)),a.v1.copy(e);const p=Math.min(d/2*.999999,n);return a.v2.copy(e).add(h.multiplyScalar(p)),a}(this.array[this.count-1].pos,t,e,r,this.count-1==0,o),h=u.getPoints(n);for(let t=0;t<n;t++)this._sharpCorner(h[t],h[t+1],a,0===t?1:0);h[n].equals(e)||this._sharpCorner(h[n],e,a,2)}else this._sharpCorner(t,e,a,0,!0)}_sharpCorner(t,e,o,a=0,u=!1){const h=this.array[this.count-1],c=this._getByIndex(this.count),d=s.subVectors(t,h.pos),l=i.subVectors(e,t),p=d.length();if(d.normalize(),l.normalize(),c.pos.copy(t),1===a?c.dir.copy(d):2===a?c.dir.copy(l):(c.dir.addVectors(d,l),c.dir.normalize()),o)1===c.dir.dot(o)?c.right.crossVectors(l,o).normalize():c.right.crossVectors(c.dir,o).normalize(),c.up.crossVectors(c.right,c.dir).normalize();else{c.up.copy(h.up);const t=r.crossVectors(h.dir,c.dir);if(t.length()>Number.EPSILON){t.normalize();const e=Math.acos(Math.min(Math.max(h.dir.dot(c.dir),-1),1));c.up.applyMatrix4(n.makeRotationAxis(t,e))}c.right.crossVectors(c.dir,c.up).normalize()}c.dist=h.dist+p;const y=d.dot(l);c.widthScale=Math.min(1/Math.sqrt((1+y)/2),1.415)||1,c.sharp=Math.abs(y-1)>.05&&u,this.count++}},t.PathTubeGeometry=class extends a{constructor(t=1e3,e=!1){super(t,e)}_initByData(t,e={},s,i){const r=h(t,e,i);r&&0!==r.count?(this.setAttribute("position",new THREE.BufferAttribute(new Float32Array(r.position),3).setUsage(s||THREE.StaticDrawUsage)),this.setAttribute("normal",new THREE.BufferAttribute(new Float32Array(r.normal),3).setUsage(s||THREE.StaticDrawUsage)),this.setAttribute("uv",new THREE.BufferAttribute(new Float32Array(r.uv),2).setUsage(s||THREE.StaticDrawUsage)),i&&this.setAttribute("uv2",new THREE.BufferAttribute(new Float32Array(r.uv2),2).setUsage(s||THREE.StaticDrawUsage)),this.setIndex(r.position.length/3>65536?new THREE.Uint32BufferAttribute(r.indices,1):new THREE.Uint16BufferAttribute(r.indices,1))):this._initByMaxVertex(2,i)}update(t,e={}){const s=!!this.getAttribute("uv2"),i=h(t,e,s);i?(this._updateAttributes(i.position,i.normal,i.uv,s?i.uv2:null,i.indices),this.drawRange.count=i.count):this.drawRange.count=0}}}));
